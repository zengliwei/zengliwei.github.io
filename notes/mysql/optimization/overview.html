<!DOCTYPE html>
<html lang="zh">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no"/>
    <meta name="keywords" content="mysql, optimization, 优化"/>
    <meta name="description" content="PHP 数组转化为 XML"/>
    <base href="/"/>
    <title></title>
    <link rel="shortcut icon" type="image/x-icon" href="web/images/favicon.ico"/>
    <link rel="stylesheet" type="text/css" href="web/css/notes.css"/>
</head>
<body>
<main>
    <article>
        <h1><span class="tag">[MySQL]</span> Optimization Overview</h1>

        <p>原文请参阅：<a target="_blank" href="https://dev.mysql.com/doc/refman/5.7/en/optimize-overview.html">https://dev.mysql.com/doc/refman/5.7/en/optimize-overview.html</a>
        </p>

        <blockquote>
            Database performance depends on several factors at the database level, such as tables, queries, and
            configuration settings. These software constructs result in CPU and I/O operations at the hardware level,
            which you must minimize and make as efficient as possible. As you work on database performance, you start by
            learning the high-level rules and guidelines for the software side, and measuring performance using
            wall-clock time. As you become an expert, you learn more about what happens internally, and start measuring
            things such as CPU cycles and I/O operations.
        </blockquote>
        <p>
            数据库性能取决于数据表、查询语句，以及数据库配置等数据库级的若干因数。
            这些软件结构作用于 CPU 和 I/O 等硬件级操作。
            初学数据库性能时，应从软件端和上层准则入手，使用进程总时间来衡量性能的高低。
            熟悉以后再深入理解其内部因素，并通过 CPU 周期和 I/O 等更细节的东西作为衡量标准。
        </p>

        <blockquote>
            Typical users aim to get the best database performance out of their existing software and hardware
            configurations. Advanced users look for opportunities to improve the MySQL software itself, or develop their
            own storage engines and hardware appliances to expand the MySQL ecosystem.
        </blockquote>
        <p>
            多数用户的目标是在他们当前的软、硬件环境下取得最优的数据库性能。
            高级用户会寻找机会提升 MySQL 软件本身，或者开发他们自己的存储引擎以及硬件设备，以扩展 MySQL 生态系统。
        </p>

        <blockquote>
            <ul>
                <li><a href="notes/mysql/optimization/overview.html#optimizing-at-the-database-level">Optimizing at the
                    Database Level</a></li>
                <li><a href="notes/mysql/optimization/overview.html#optimizing-at-the-hardware-level">Optimizing at the
                    Hardware Level</a></li>
                <li><a href="notes/mysql/optimization/overview.html#balancing-portability-and-performance">Balancing
                    Portability and Performance</a></li>
            </ul>
        </blockquote>
        <ul>
            <li><a href="notes/mysql/optimization/overview.html#optimizing-at-the-database-level">数据库级优化</a></li>
            <li><a href="notes/mysql/optimization/overview.html#optimizing-at-the-hardware-level">硬件级优化</a></li>
            <li><a href="notes/mysql/optimization/overview.html#balancing-portability-and-performance">平衡性能和可移植性</a>
            </li>
        </ul>

        <h2 id="optimizing-at-the-database-level">Optimizing at the Database Level</h2>

        <blockquote>The most important factor in making a database application fast is its basic design:</blockquote>
        <p>提升一个数据库应用的最重要的因素是他的基础设计：</p>

        <blockquote>
            Are the tables structured properly? In particular, do the columns have the right data types, and does each
            table have the appropriate columns for the type of work? For example, applications that perform frequent
            updates often have many tables with few columns, while applications that analyze large amounts of data often
            have few tables with many columns.
        </blockquote>

        <blockquote>
            Are the right indexes in place to make queries efficient?
        </blockquote>

        <blockquote>
            Are you using the appropriate storage engine for each table, and taking advantage of the strengths and
            features of each storage engine you use? In particular, the choice of a transactional storage engine such as
            InnoDB or a non-transactional one such as MyISAM can be very important for performance and scalability.
        </blockquote>

        <blockquote>
            Note
            InnoDB is the default storage engine for new tables. In practice, the advanced InnoDB performance features
            mean that InnoDB tables often outperform the simpler MyISAM tables, especially for a busy database.
        </blockquote>

        <blockquote>
            Does each table use an appropriate row format? This choice also depends on the storage engine used for the
            table. In particular, compressed tables use less disk space and so require less disk I/O to read and write
            the data. Compression is available for all kinds of workloads with InnoDB tables, and for read-only MyISAM
            tables.
        </blockquote>

        <blockquote>
            Does the application use an appropriate locking strategy? For example, by allowing shared access when
            possible so that database operations can run concurrently, and requesting exclusive access when appropriate
            so that critical operations get top priority. Again, the choice of storage engine is significant. The InnoDB
            storage engine handles most locking issues without involvement from you, allowing for better concurrency in
            the database and reducing the amount of experimentation and tuning for your code.
        </blockquote>

        <blockquote>
            Are all memory areas used for caching sized correctly? That is, large enough to hold frequently accessed
            data, but not so large that they overload physical memory and cause paging. The main memory areas to
            configure are the InnoDB buffer pool, the MyISAM key cache, and the MySQL query cache.
        </blockquote>

        <h2 id="optimizing-at-the-hardware-level">Optimizing at the Hardware Level</h2>

        <blockquote>
            Any database application eventually hits hardware limits as the database becomes more and more busy. A DBA
            must evaluate whether it is possible to tune the application or reconfigure the server to avoid these
            bottlenecks, or whether more hardware resources are required. System bottlenecks typically arise from these
            sources:
        </blockquote>

        <blockquote>
            Disk seeks. It takes time for the disk to find a piece of data. With modern disks, the mean time for this is
            usually lower than 10ms, so we can in theory do about 100 seeks a second. This time improves slowly with new
            disks and is very hard to optimize for a single table. The way to optimize seek time is to distribute the
            data onto more than one disk.
        </blockquote>

        <blockquote>
            Disk reading and writing. When the disk is at the correct position, we need to read or write the data. With
            modern disks, one disk delivers at least 10–20MB/s throughput. This is easier to optimize than seeks because
            you can read in parallel from multiple disks.
        </blockquote>

        <blockquote>
            CPU cycles. When the data is in main memory, we must process it to get our result. Having large tables
            compared to the amount of memory is the most common limiting factor. But with small tables, speed is usually
            not the problem.
        </blockquote>

        <blockquote>
            Memory bandwidth. When the CPU needs more data than can fit in the CPU cache, main memory bandwidth becomes
            a bottleneck. This is an uncommon bottleneck for most systems, but one to be aware of.
        </blockquote>

        <h2 id="balancing-portability-and-performance">Balancing Portability and Performance</h2>

        <blockquote>
            To use performance-oriented SQL extensions in a portable MySQL program, you can wrap MySQL-specific keywords
            in a statement within /*! */ comment delimiters. Other SQL servers ignore the commented keywords. For
            information about writing comments, see Section 9.6, “Comments”.
        </blockquote>

    </article>
</main>
<script src="web/js/lib/require.js" type="text/javascript"></script>
<script src="web/js/require-config.js" type="text/javascript"></script>
<script src="web/js/notes.js" type="text/javascript"></script>
</body>
</html>