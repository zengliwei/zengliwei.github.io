<!DOCTYPE html>
<html lang="zh">
<head>
    <base href="/"/>
    <title>[MySQL] InnoDB 表优化</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no"/>
    <meta name="keywords" content="mysql, optimization, innodb, 优化"/>
    <meta name="description" content="PHP 数组转化为 XML"/>
    <link rel="shortcut icon" type="image/x-icon" href="web/images/favicon.ico"/>
    <link rel="stylesheet" type="text/css" href="web/css/notes.css"/>
</head>
<body>
<main>
    <h1>
        <span class="tag">[MySQL]</span>
        <span>[译] Optimizing for InnoDB Tables</span>
        <span class="translation">InnoDB 表优化</span>
    </h1>

    <p>原文请参阅：<a target="_blank" href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb.html">https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb.html</a>
    </p>

    <ul>
        <li><a href="notes/mysql/optimization/innodb.html#optimizing-innodb-storage-layout">InnoDB 表存储布局优化</a>
        </li>
        <li><a href="notes/mysql/optimization/innodb.html#optimizing-innodb-transaction-management">InnoDB
            事务管理</a>
        </li>
        <li><a href="notes/mysql/optimization/innodb.html#innodb-performance-ro-txn">InnoDB 只读事务优化</a></li>
        <li><a href="notes/mysql/optimization/innodb.html#optimizing-innodb-logging">InnoDB Redo 日志优化</a></li>
        <li><a href="notes/mysql/optimization/innodb.html#optimizing-innodb-bulk-data-loading">InnoDB
            表的数据批量加载</a>
        </li>
        <li><a href="notes/mysql/optimization/innodb.html#optimizing-innodb-queries">InnoDB 查询</a></li>
        <li><a href="notes/mysql/optimization/innodb.html#optimizing-innodb-ddl-operations">InnoDB DDL 操作优化</a>
        </li>
        <li><a href="notes/mysql/optimization/innodb.html#optimizing-innodb-diskio">InnoDB 磁盘 I/O 优化</a></li>
        <li><a href="notes/mysql/optimization/innodb.html#optimizing-innodb-configuration-variables">InnoDB
            配置优化</a></li>
        <li><a href="notes/mysql/optimization/innodb.html#optimizing-innodb-many-tables">InnoDB 多表优化</a></li>
    </ul>

    <h2 id="optimizing-innodb-storage-layout">InnoDB 表存储布局优化</h2>

    <p>原文请参阅：<a target="_blank" href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-storage-layout.html">https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-storage-layout.html</a>
    </p>

    <p>
        当表的数据量到达稳定值，或者增加了一定量时，可考虑使用 <code>OPTIMIZE TABLE</code> 语句进行整理以压缩空间。
        整理后的表进行全表扫描所产生的磁盘 I/O 将更少。
        当其他技术，如增加索引或调整程序代码不起作用时，可尝试用这种方法来提高性能。
    </p>
    <p>
        <code>OPTIMIZE TABLE</code> 方法复制表的部分数据来重建索引。通过使用索引打包数据，压缩表空间和磁盘碎片。
        这种优化的结果取决于表的数据，可能出现只有一部分表有效，或者收益随时间推移逐渐降低的情况。
        当表很大或者缓存池尺寸不适用于重建的索引时，这个操作会很费时。增加大量数据后的第一次运行通常比后续操作慢很多。
    </p>
    <p>
        使用 InnoDB 引擎的表，长主键（不管是单列还是多列组合）会浪费大量磁盘空间。
        主键值会在所有指向同一行的二级索引记录中重复出现（见
        <a target="_blank" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html">Section
            14.6.2.1, “Clustered and Secondary Indexes”</a>）。
        当主键太长时，应该创建一个自增字段作为主键，或者对长 VARCHAR 列的前边部分而不是整个列进行索引。
    </p>
    <p>
        应使用 VARCHAR 而不是 CHAR 来存储变长字符串，以及可能频繁出现空值的数据。
        一个 CHAR(N) 型字段总是占用 N 个字符空间，即使字符串很短甚至为 NULL。
        小表更适用于缓存池，减少磁盘 I/O。
    </p>
    <p>
        当使用 COMPACT 格式（InnoDB 默认）和像 utf8 或 sjis 这样的变长字符集时，CHAR(N) 型字段所占用的空间是不固定的，但至少是 N 字节。
    </p>
    <p>
        对于大表或者包含大量重复数据的表，应考虑使用 COMPRESSED 行格式，这样不管访问缓冲池还是进行全表扫描所产生的磁盘 I/O 都将更少。
        在决定使用哪种格式之前，应先测试各自的压缩量。
    </p>


    <h2 id="optimizing-innodb-transaction-management">InnoDB 事务管理</h2>

    <p>原文请参阅：<a target="_blank"
                href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-transaction-management.html">https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-transaction-management.html</a>
    </p>

    <p>
        要优化 InnoDB 事务处理，应先找到事务特性的开销与服务器工作负载之间的平衡点。
        比如，应用在一秒内提交上千次请求遇到了性能问题，但同样的请求在 2 到 3 小时内提交则没有出现这个问题。
    </p>
    <p>
        MySQL 的默认设置 AUTOCOMMIT=1 可能会让繁忙的数据库服务器产生性能问题。
        这时，应根据实际情况通过 <code>SET AUTOCOMMIT=0</code> 或 <code>START TRANSACTION</code> 语句发出事务声明，
        将多项数据变更操作封装到一个事务中，再用 <code>COMMIT</code> 语句执行这个事务。
    </p>
    <p>
        如果一个事务将对数据库进行修改，InnoDB 会在它提交后将日志刷新到磁盘中。
        如果每一项修改操作都立即提交（默认设置），它有可能严重影响存储设备的每秒 I/O 吞吐量。
    </p>
    <p>
        对于只包含一个 <a target="_blank" href="https://dev.mysql.com/doc/refman/5.7/en/select.html">SELECT</a>
        语句的事务，打开 AUTOCOMMIT 有利于 InnoDB 对其进行只读识别和优化。见 “<a
            href="notes/mysql/optimization/innodb.html#innodb-performance-ro-txn">InnoDB 只读事务优化</a>”。
    </p>
    <p>
        应尽量避免在插入、更新或删除大批量数据后进行回滚。
        如果一个事务影响了服务器性能，那么对它进行回滚会让情况变得更差，回滚花的时间通常是原来的几倍。
        关闭进程没有意义，因为服务器重启后回滚操作会再次自动执行。
    </p>
    <p>以下操作可以避免性能问题：</p>
    <ul>
        <li>增加缓存池大小，以便所有数据修改都通过缓存进行，而不是立即写入磁盘</li>
        <li>设置 <a target="_blank"
                  href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_change_buffering">innodb_change_buffering=all</a>
            让更新和删除操作也使用缓存
        </li>
        <li>将大数据变更操作拆分成多次小批量操作</li>
    </ul>
    <p>
        如 “<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-recovery.html">InnoDB Recovery</a>” 所述，
        要消除失控性回滚，应增加缓存池大小，让回滚操作全部绑定 CPU 快速执行；
        或者关闭服务器，并通过参数 <a target="_blank"
                         href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_force_recovery">innodb_force_recovery=3</a>
        进行重启。
    </p>
    <p>
        默认设置 <a target="_blank"
                href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_change_buffering">innodb_change_buffering=all</a>
        允许将更新、删除及其回滚操作都通过缓存快速执行。
        应确保在频繁进行插入、更新或删除操作的服务器上启用此参数。
    </p>
    <p>
        如果你能接受因意外退出服务导致最后一次更新操作的数据丢失，可以将
        <a target="_blank"
           href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit">innodb_flush_log_at_trx_commit</a>
        参数设为 0。
        这样 InnoDB 会改变策略，由每次提交事务都刷新日志变为每秒刷新一次，以此减少由数据同步和更新二进制日志所产生的磁盘刷新次数。
    </p>
    <p>
        注：innodb_support_xa 参数已被弃用，且将在后续版本中删除。
        从 MySQL 5.7.10 起，始终启用 InnoDB 对 XA 事务两阶段提交的支持，不再允许通过 innodb_support_xa 参数进行禁用。
    </p>
    <p>
        修改或删除行数据时，其内容以及相关的 undo log 不会立即被物理性删除，甚至不会在事务提交后立即删除。
        旧数据将被保留，直到同期执行的事务全部完成，以便有需要时系统可以重新取得数据更新前的状态。
        因此，长时间运行的事务会阻止 InnoDB 清除期间由其它事务修改的数据。
    </p>
    <p>
        当行数据被一个长时间运行的事务修改或删除，此时若其它使用
        <a target="_blank"
           href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_read-committed">READ
            COMMITTED</a> 或
        <a target="_blank"
           href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read">REPEATABLE
            READ</a> 隔离级别的事务读取这些数据，
        系统需要执行更多操作来重现旧数据。
    </p>
    <p>
        当一个长时间运行的事务修改了一个表，这期间其它事务对这个表的查询将不会使用全覆盖索引技术直接从索引读取内容，
        而是先走二级索引定位记录，再从表里提取合适的数据。
    </p>
    <p>
        当二级索引页中存在太新的 PAGE_MAX_TRX_ID，或者其中的记录被标记为已删除，InnoDB 会转为通过聚合索引检索数据。
    </p>

    <h2 id="innodb-performance-ro-txn">InnoDB 只读事务优化</h2>

    <p>原文请参阅：<a target="_blank" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-ro-txn.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-ro-txn.html</a>
    </p>

    <p>
        InnoDB 不会为只读事务设定事务 ID（TRX_ID 字段），事务 ID 只用于包含写操作或加锁读操作的事务。
        消除不必要的事务 ID 可以为每次查询或更新操作减少内部数据结构所使用的空间。
    </p>
    <p>
        InnoDB 于以下情景将事务标识为只读：
    </p>
    <ul>
        <li>
            <p>
                使用 <a target="_blank" href="https://dev.mysql.com/doc/refman/5.7/en/commit.html">START TRANSACTION
                READ ONLY</a> 定义的事务。
                这种情况下，对数据库的任意修改（包括 InnoDB、MyISAM 或者其它引擎的表）都会触发以下错误，且事务会保持只读状态：
            </p>
            <pre><code>ERROR 1792 (25006): Cannot execute statement in a READ ONLY transaction.</code></pre>
            <p>
                在只读事务中仍然可以修改或锁定指定会话中的临时表，因为这些修改对于其它事务来说都是不可见的。
            </p>
        </li>
        <li>
            参数 <a target="_blank"
                  href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_autocommit">autocommit</a>
            已开启，保证每个事务都只有一条语句，且执行一个没加锁的 SELECT 语句。<br/><br/>
        </li>
        <li>
            事务没有以 READ ONLY 定义，但也没有执行显式的更新或加锁语句。在执行这类语句之前，事务都被视作只读。
        </li>
    </ul>
    <p>
        因此，对于一个类似报表生成器的读密集型应用，可以使用 START TRANSACTION READ ONLY 和 COMMIT 包装 InnoDB 查询序列，
        或者在执行 SELECT 语句之前启用 autocommit 设置，或者避免在请求中执行数据更新语句。
    </p>
    <p>
        关于 START TRANSACTION 和 autocommit 的更多信息，请参阅
        “<a target="_blank" href="https://dev.mysql.com/doc/refman/5.7/en/commit.html">START
        TRANSACTION, COMMIT, and ROLLBACK Statements</a>”。
    </p>
    <p>
        注：符合自动提交、非锁定和只读（AC-NL-RO）条件的事务被排除在某些内部 InnoDB 数据结构之外，因此不在
        <a target="_blank" href="https://dev.mysql.com/doc/refman/5.7/en/show-engine.html">SHOW ENGINE InnoDB
            STATUS</a>
        中列出。
    </p>

    <h2 id="optimizing-innodb-logging">InnoDB Redo 日志优化</h2>

    <p>原文请参阅：<a target="_blank" href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-logging.html">https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-logging.html</a>
    </p>

    <p>Consider the following guidelines for optimizing redo logging:</p>

    <p>Make your redo log files big, even as big as the buffer pool. When InnoDB has written the redo log files
        full, it must write the modified contents of the buffer pool to disk in a checkpoint. Small redo log files
        cause many unnecessary disk writes. Although historically big redo log files caused lengthy recovery times,
        recovery is now much faster and you can confidently use large redo log files.</p>

    <p>The size and number of redo log files are configured using the innodb_log_file_size and
        innodb_log_files_in_group configuration options. For information about modifying an existing redo log file
        configuration, see Changing the Number or Size of InnoDB Redo Log Files.</p>

    <p>Consider increasing the size of the log buffer. A large log buffer enables large transactions to run without
        a need to write the log to disk before the transactions commit. Thus, if you have transactions that update,
        insert, or delete many rows, making the log buffer larger saves disk I/O. Log buffer size is configured
        using the innodb_log_buffer_size configuration option.</p>

    <p>Configure the innodb_log_write_ahead_size configuration option to avoid “read-on-write”. This option defines
        the write-ahead block size for the redo log. Set innodb_log_write_ahead_size to match the operating system
        or file system cache block size. Read-on-write occurs when redo log blocks are not entirely cached to the
        operating system or file system due to a mismatch between write-ahead block size for the redo log and
        operating system or file system cache block size.</p>

    <p>Valid values for innodb_log_write_ahead_size are multiples of the InnoDB log file block size (2n). The
        minimum value is the InnoDB log file block size (512). Write-ahead does not occur when the minimum value is
        specified. The maximum value is equal to the innodb_page_size value. If you specify a value for
        innodb_log_write_ahead_size that is larger than the innodb_page_size value, the innodb_log_write_ahead_size
        setting is truncated to the innodb_page_size value.</p>

    <p>Setting the innodb_log_write_ahead_size value too low in relation to the operating system or file system
        cache block size results in read-on-write. Setting the value too high may have a slight impact on fsync
        performance for log file writes due to several blocks being written at once.</p>


    <h2 id="optimizing-innodb-bulk-data-loading">InnoDB 表的数据批量加载</h2>

    <p>原文请参阅：<a target="_blank" href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-bulk-data-loading.html">https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-bulk-data-loading.html</a>
    </p>

    <p>
        本章的性能提示补充了
        “<a target="_blank" href="https://dev.mysql.com/doc/refman/5.7/en/insert-optimization.html">Optimizing
        INSERT
        Statements</a>” 的内容。
    </p>

    <p>
        将数据导入 InnoDB 表时应关闭自动提交模式，因为每次插入操作都会刷新磁盘日志。
        要在导入操作期间禁用自动提交，可使用 SET autocommit 和 COMMIT 将导入语句包起来：
    </p>

    <pre><code>SET autocommit=0;
... SQL import statements ...
COMMIT;</code></pre>

    <p>
        使用 mysqldump 命令的 --opt 参数，即使不带 SET autocommit 和 COMMIT 语句也能创建用于快速导入的转储文件。
    </p>

    <p>
        如果二级索引包含 UNIQUE 约束，可以通过临时关闭唯一性检查来加速导入操作：
    </p>

    <pre><code>SET unique_checks=0;
... SQL import statements ...
SET unique_checks=1;</code></pre>

    <p>
        对大表来说，这项操作将节省大量磁盘 I/O，因为 InnoDB 可以通过更新缓存来批量写入二级索引。
        但操作前须确保数据中不包含重复的关键字。
    </p>

    <p>
        如果二级索引包含 FOREIGN KEY 约束，可以通过临时关闭外键检查来加速导入操作：
    </p>

    <pre><code>SET foreign_key_checks=0;
... SQL import statements ...
SET foreign_key_checks=1;</code></pre>

    <p>对大表来说，这项操作将节省大量磁盘 I/O。</p>

    <p>插入多行数据时应使用专用语法来降低客户端与服务器之间的通信开销：</p>

    <pre><code>INSERT INTO yourtable VALUES (1,2), (5,5), ...;</code></pre>

    <p>这个方法对除 InnoDB 以外的引擎也有效。</p>

    <p>往带自增字段的表批量插入数据时，可将参数
        <a target="_blank"
           href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode</a>
        设为 2。详见 “<a target="_blank"
                    href="https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html">AUTO_INCREMENT
            Handling in InnoDB</a>”</p>

    <p>由于 InnoDB 表使用聚合索引，因此插入大批量数据时，按主键顺序来操作速度更快。
        对不能被完全缓存的表来说，按主键顺序插入数据尤为重要。</p>


    <h2 id="optimizing-innodb-queries">InnoDB 查询</h2>

    <p>原文请参阅：<a target="_blank" href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-queries.html">https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-queries.html</a>
    </p>

    <p>
        To tune queries for InnoDB tables, create an appropriate set of indexes on each table. See Section 8.3.1, “How
        MySQL Uses Indexes” for details. Follow these guidelines for InnoDB indexes:
    </p>

    <p>
        Because each InnoDB table has a primary key (whether you request one or not), specify a set of primary key
        columns for each table, columns that are used in the most important and time-critical queries.
    </p>

    <p>
        Do not specify too many or too long columns in the primary key, because these column values are duplicated in
        each secondary index. When an index contains unnecessary data, the I/O to read this data and memory to cache it
        reduce the performance and scalability of the server.
    </p>

    <p>
        Do not create a separate secondary index for each column, because each query can only make use of one index.
        Indexes on rarely tested columns or columns with only a few different values might not be helpful for any
        queries. If you have many queries for the same table, testing different combinations of columns, try to create a
        small number of concatenated indexes rather than a large number of single-column indexes. If an index contains
        all the columns needed for the result set (known as a covering index), the query might be able to avoid reading
        the table data at all.
    </p>

    <p>
        If an indexed column cannot contain any NULL values, declare it as NOT NULL when you create the table. The
        optimizer can better determine which index is most effective to use for a query, when it knows whether each
        column contains NULL values.
    </p>

    <p>
        You can optimize single-query transactions for InnoDB tables, using the technique in Section 8.5.3, “Optimizing
        InnoDB Read-Only Transactions”.
    </p>


    <h2 id="optimizing-innodb-ddl-operations">InnoDB DDL 操作优化</h2>

    <p>原文请参阅：<a target="_blank" href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-ddl-operations.html">https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-ddl-operations.html</a>
    </p>

    <p>
        Many DDL operations on tables and indexes (CREATE, ALTER, and DROP statements) can be performed online. See
        Section 14.13, “InnoDB and Online DDL” for details.
    </p>

    <p>
        Online DDL support for adding secondary indexes means that you can generally speed up the process of creating
        and loading a table and associated indexes by creating the table without secondary indexes, then adding
        secondary indexes after the data is loaded.
    </p>

    <p>
        Use TRUNCATE TABLE to empty a table, not DELETE FROM tbl_name. Foreign key constraints can make a TRUNCATE
        statement work like a regular DELETE statement, in which case a sequence of commands like DROP TABLE and CREATE
        TABLE might be fastest.
    </p>

    <p>
        Because the primary key is integral to the storage layout of each InnoDB table, and changing the definition of
        the primary key involves reorganizing the whole table, always set up the primary key as part of the CREATE TABLE
        statement, and plan ahead so that you do not need to ALTER or DROP the primary key afterward.
    </p>


    <h2 id="optimizing-innodb-diskio">InnoDB 磁盘 I/O 优化</h2>

    <p>原文请参阅：<a target="_blank" href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-diskio.html">https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-diskio.html</a>
    </p>

    <p>
        If you follow best practices for database design and tuning techniques for SQL operations, but your database is
        still slow due to heavy disk I/O activity, consider these disk I/O optimizations. If the Unix top tool or the
        Windows Task Manager shows that the CPU usage percentage with your workload is less than 70%, your workload is
        probably disk-bound.
    </p>

    <p>
        Increase buffer pool size
    </p>

    <p>
        When table data is cached in the InnoDB buffer pool, it can be accessed repeatedly by queries without requiring
        any disk I/O. Specify the size of the buffer pool with the innodb_buffer_pool_size option. This memory area is
        important enough that it is typically recommended that innodb_buffer_pool_size is configured to 50 to 75 percent
        of system memory. For more information see, Section 8.12.4.1, “How MySQL Uses Memory”.
    </p>

    <p>
        Adjust the flush method
    </p>

    <p>
        In some versions of GNU/Linux and Unix, flushing files to disk with the Unix fsync() call (which InnoDB uses by
        default) and similar methods is surprisingly slow. If database write performance is an issue, conduct benchmarks
        with the innodb_flush_method parameter set to O_DSYNC.
    </p>

    <p>
        Use a noop or deadline I/O scheduler with native AIO on Linux
    </p>

    <p>
        InnoDB uses the asynchronous I/O subsystem (native AIO) on Linux to perform read-ahead and write requests for
        data file pages. This behavior is controlled by the innodb_use_native_aio configuration option, which is enabled
        by default. With native AIO, the type of I/O scheduler has greater influence on I/O performance. Generally, noop
        and deadline I/O schedulers are recommended. Conduct benchmarks to determine which I/O scheduler provides the
        best results for your workload and environment. For more information, see Section 14.8.7, “Using Asynchronous
        I/O on Linux”.
    </p>

    <p>
        Use direct I/O on Solaris 10 for x86_64 architecture
    </p>

    <p>
        When using the InnoDB storage engine on Solaris 10 for x86_64 architecture (AMD Opteron), use direct I/O for
        InnoDB-related files to avoid degradation of InnoDB performance. To use direct I/O for an entire UFS file system
        used for storing InnoDB-related files, mount it with the forcedirectio option; see mount_ufs(1M). (The default
        on Solaris 10/x86_64 is not to use this option.) To apply direct I/O only to InnoDB file operations rather than
        the whole file system, set innodb_flush_method = O_DIRECT. With this setting, InnoDB calls directio() instead of
        fcntl() for I/O to data files (not for I/O to log files).
    </p>

    <p>
        Use raw storage for data and log files with Solaris 2.6 or later
    </p>

    <p>
        When using the InnoDB storage engine with a large innodb_buffer_pool_size value on any release of Solaris 2.6
        and up and any platform (sparc/x86/x64/amd64), conduct benchmarks with InnoDB data files and log files on raw
        devices or on a separate direct I/O UFS file system, using the forcedirectio mount option as described
        previously. (It is necessary to use the mount option rather than setting innodb_flush_method if you want direct
        I/O for the log files.) Users of the Veritas file system VxFS should use the convosync=direct mount option.
    </p>

    <p>
        Do not place other MySQL data files, such as those for MyISAM tables, on a direct I/O file system. Executables
        or libraries must not be placed on a direct I/O file system.
    </p>

    <p>
        Use additional storage devices
    </p>

    <p>
        Additional storage devices could be used to set up a RAID configuration. For related information, see Section
        8.12.2, “Optimizing Disk I/O”.
    </p>

    <p>
        Alternatively, InnoDB tablespace data files and log files can be placed on different physical disks. For more
        information, refer to the following sections:
    </p>

    <p>
        Section 14.8.1, “InnoDB Startup Configuration”
    </p>

    <p>
        Section 14.6.1.2, “Creating Tables Externally”
    </p>

    <p>
        Creating a General Tablespace
    </p>

    <p>
        Section 14.6.1.4, “Moving or Copying InnoDB Tables”
    </p>

    <p>
        Consider non-rotational storage
    </p>

    <p>
        Non-rotational storage generally provides better performance for random I/O operations; and rotational storage
        for sequential I/O operations. When distributing data and log files across rotational and non-rotational storage
        devices, consider the type of I/O operations that are predominantly performed on each file.
    </p>

    <p>
        Random I/O-oriented files typically include file-per-table and general tablespace data files, undo tablespace
        files, and temporary tablespace files. Sequential I/O-oriented files include InnoDB system tablespace files (due
        to doublewrite buffering and change buffering) and log files such as binary log files and redo log files.
    </p>

    <p>
        Review settings for the following configuration options when using non-rotational storage:
    </p>

    <p>
        innodb_checksum_algorithm
    </p>

    <p>
        The crc32 option uses a faster checksum algorithm and is recommended for fast storage systems.
    </p>

    <p>
        innodb_flush_neighbors
    </p>

    <p>
        Optimizes I/O for rotational storage devices. Disable it for non-rotational storage or a mix of rotational and
        non-rotational storage.
    </p>

    <p>
        innodb_io_capacity
    </p>

    <p>
        The default setting of 200 is generally sufficient for a lower-end non-rotational storage device. For
        higher-end, bus-attached devices, consider a higher setting such as 1000.
    </p>

    <p>
        innodb_io_capacity_max
    </p>

    <p>
        The default value of 2000 is intended for workloads that use non-rotational storage. For a high-end,
        bus-attached non-rotational storage device, consider a higher setting such as 2500.
    </p>

    <p>
        innodb_log_compressed_pages
    </p>

    <p>
        If redo logs are on non-rotational storage, consider disabling this option to reduce logging. See Disable
        logging of compressed pages.
    </p>

    <p>
        innodb_log_file_size
    </p>

    <p>
        If redo logs are on non-rotational storage, configure this option to maximize caching and write combining.
    </p>

    <p>
        innodb_page_size
    </p>

    <p>
        Consider using a page size that matches the internal sector size of the disk. Early-generation SSD devices often
        have a 4KB sector size. Some newer devices have a 16KB sector size. The default InnoDB page size is 16KB.
        Keeping the page size close to the storage device block size minimizes the amount of unchanged data that is
        rewritten to disk.
    </p>

    <p>
        binlog_row_image
    </p>

    <p>
        If binary logs are on non-rotational storage and all tables have primary keys, consider setting this option to
        minimal to reduce logging.
    </p>

    <p>
        Ensure that TRIM support is enabled for your operating system. It is typically enabled by default.
    </p>

    <p>
        Increase I/O capacity to avoid backlogs
    </p>

    <p>
        If throughput drops periodically because of InnoDB checkpoint operations, consider increasing the value of the
        innodb_io_capacity configuration option. Higher values cause more frequent flushing, avoiding the backlog of
        work that can cause dips in throughput.
    </p>

    <p>
        Lower I/O capacity if flushing does not fall behind
    </p>

    <p>
        If the system is not falling behind with InnoDB flushing operations, consider lowering the value of the
        innodb_io_capacity configuration option. Typically, you keep this option value as low as practical, but not so
        low that it causes periodic drops in throughput as mentioned in the preceding bullet. In a typical scenario
        where you could lower the option value, you might see a combination like this in the output from SHOW ENGINE
        INNODB STATUS:
    </p>

    <p>
        History list length low, below a few thousand.
    </p>

    <p>
        Insert buffer merges close to rows inserted.
    </p>

    <p>
        Modified pages in buffer pool consistently well below innodb_max_dirty_pages_pct of the buffer pool. (Measure at
        a time when the server is not doing bulk inserts; it is normal during bulk inserts for the modified pages
        percentage to rise significantly.)
    </p>

    <p>
        Log sequence number - Last checkpoint is at less than 7/8 or ideally less than 6/8 of the total size of the
        InnoDB log files.
    </p>

    <p>
        Store system tablespace files on Fusion-io devices
    </p>

    <p>
        You can take advantage of a doublewrite buffer-related I/O optimization by storing system tablespace files
        (“ibdata files”) on Fusion-io devices that support atomic writes. In this case, doublewrite buffering
        (innodb_doublewrite) is automatically disabled and Fusion-io atomic writes are used for all data files. This
        feature is only supported on Fusion-io hardware and is only enabled for Fusion-io NVMFS on Linux. To take full
        advantage of this feature, an innodb_flush_method setting of O_DIRECT is recommended.
    </p>

    <p>
        Note: Because the doublewrite buffer setting is global, doublewrite buffering is also disabled for data files
        residing on non-Fusion-io hardware.
    </p>

    <p>
        Disable logging of compressed pages
    </p>

    <p>
        When using the InnoDB table compression feature, images of re-compressed pages are written to the redo log when
        changes are made to compressed data. This behavior is controlled by innodb_log_compressed_pages, which is
        enabled by default to prevent corruption that can occur if a different version of the zlib compression algorithm
        is used during recovery. If you are certain that the zlib version is not subject to change, disable
        innodb_log_compressed_pages to reduce redo log generation for workloads that modify compressed data.
    </p>


    <h2 id="optimizing-innodb-configuration-variables">InnoDB 配置优化</h2>

    <p>原文请参阅：<a target="_blank"
                href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-configuration-variables.html">https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-configuration-variables.html</a>
    </p>

    <p>
        Different settings work best for servers with light, predictable loads, versus servers that are running near
        full capacity all the time, or that experience spikes of high activity.
    </p>

    <p>
        Because the InnoDB storage engine performs many of its optimizations automatically, many performance-tuning
        tasks involve monitoring to ensure that the database is performing well, and changing configuration options when
        performance drops. See Section 14.17, “InnoDB Integration with MySQL Performance Schema” for information about
        detailed InnoDB performance monitoring.
    </p>

    <p>
        The main configuration steps you can perform include:
    </p>

    <p>
        Enabling InnoDB to use high-performance memory allocators on systems that include them. See Section 14.8.4,
        “Configuring the Memory Allocator for InnoDB”.
    </p>

    <p>
        Controlling the types of data change operations for which InnoDB buffers the changed data, to avoid frequent
        small disk writes. See Configuring Change Buffering. Because the default is to buffer all types of data change
        operations, only change this setting if you need to reduce the amount of buffering.
    </p>

    <p>
        Turning the adaptive hash indexing feature on and off using the innodb_adaptive_hash_index option. See Section
        14.5.3, “Adaptive Hash Index” for more information. You might change this setting during periods of unusual
        activity, then restore it to its original setting.
    </p>

    <p>
        Setting a limit on the number of concurrent threads that InnoDB processes, if context switching is a bottleneck.
        See Section 14.8.5, “Configuring Thread Concurrency for InnoDB”.
    </p>

    <p>
        Controlling the amount of prefetching that InnoDB does with its read-ahead operations. When the system has
        unused I/O capacity, more read-ahead can improve the performance of queries. Too much read-ahead can cause
        periodic drops in performance on a heavily loaded system. See Section 14.8.3.4, “Configuring InnoDB Buffer Pool
        Prefetching (Read-Ahead)”.
    </p>

    <p>
        Increasing the number of background threads for read or write operations, if you have a high-end I/O subsystem
        that is not fully utilized by the default values. See Section 14.8.6, “Configuring the Number of Background
        InnoDB I/O Threads”.
    </p>

    <p>
        Controlling how much I/O InnoDB performs in the background. See Section 14.8.8, “Configuring InnoDB I/O
        Capacity”. You might scale back this setting if you observe periodic drops in performance.
    </p>

    <p>
        Controlling the algorithm that determines when InnoDB performs certain types of background writes. See Section
        14.8.3.5, “Configuring Buffer Pool Flushing”. The algorithm works for some types of workloads but not others, so
        might turn off this setting if you observe periodic drops in performance.
    </p>

    <p>
        Taking advantage of multicore processors and their cache memory configuration, to minimize delays in context
        switching. See Section 14.8.9, “Configuring Spin Lock Polling”.
    </p>

    <p>
        Preventing one-time operations such as table scans from interfering with the frequently accessed data stored in
        the InnoDB buffer cache. See Section 14.8.3.3, “Making the Buffer Pool Scan Resistant”.
    </p>

    <p>
        Adjusting log files to a size that makes sense for reliability and crash recovery. InnoDB log files have often
        been kept small to avoid long startup times after a crash. Optimizations introduced in MySQL 5.5 speed up
        certain steps of the crash recovery process. In particular, scanning the redo log and applying the redo log are
        faster due to improved algorithms for memory management. If you have kept your log files artificially small to
        avoid long startup times, you can now consider increasing log file size to reduce the I/O that occurs due
        recycling of redo log records.
    </p>

    <p>
        Configuring the size and number of instances for the InnoDB buffer pool, especially important for systems with
        multi-gigabyte buffer pools. See Section 14.8.3.2, “Configuring Multiple Buffer Pool Instances”.
    </p>

    <p>
        Increasing the maximum number of concurrent transactions, which dramatically improves scalability for the
        busiest databases. See Section 14.6.7, “Undo Logs”.
    </p>

    <p>
        Moving purge operations (a type of garbage collection) into a background thread. See Section 14.8.10, “Purge
        Configuration”. To effectively measure the results of this setting, tune the other I/O-related and
        thread-related configuration settings first.
    </p>

    <p>
        Reducing the amount of switching that InnoDB does between concurrent threads, so that SQL operations on a busy
        server do not queue up and form a “traffic jam”. Set a value for the innodb_thread_concurrency option, up to
        approximately 32 for a high-powered modern system. Increase the value for the innodb_concurrency_tickets option,
        typically to 5000 or so. This combination of options sets a cap on the number of threads that InnoDB processes
        at any one time, and allows each thread to do substantial work before being swapped out, so that the number of
        waiting threads stays low and operations can complete without excessive context switching.
    </p>


    <h2 id="optimizing-innodb-many-tables">InnoDB 多表优化</h2>

    <p>原文请参阅：<a target="_blank" href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-many-tables.html">https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-many-tables.html</a>
    </p>

    <p>
        If you have configured non-persistent optimizer statistics (a non-default configuration), InnoDB computes index
        cardinality values for a table the first time that table is accessed after startup, instead of storing such
        values in the table. This step can take significant time on systems that partition the data into many tables.
        Since this overhead only applies to the initial table open operation, to “warm up” a table for later use, access
        it immediately after startup by issuing a statement such as SELECT 1 FROM tbl_name LIMIT 1.
    </p>

    <p>
        Optimizer statistics are persisted to disk by default, enabled by the innodb_stats_persistent configuration
        option. For information about persistent optimizer statistics, see Section 14.8.11.1, “Configuring Persistent
        Optimizer Statistics Parameters”.
    </p>
</main>
<script src="web/js/lib/require.js" type="text/javascript"></script>
<script src="web/js/require-config.js" type="text/javascript"></script>
<script src="web/js/notes.js" type="text/javascript"></script>
</body>
</html>